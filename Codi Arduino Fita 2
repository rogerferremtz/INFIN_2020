#define DEBUG(a, b) for (int index = 0; index < b; index++) Serial.print(a[index]); Serial.println(); //Instrucció per escriure al port serie la comanda del mestre

#include <avr/sleep.h>

void setup()
{
   Serial.begin(9600);
   Serial.setTimeout(50);
   //analogReference( INTERNAL );
   // REFS1 REFS0          --> 0 0 AREF, Internal Vref turned off
   // MUX3 MUX2 MUX1 MUX0  --> 1110 1.1V (VBG)
   ADMUX = (1<<REFS1) | (1<<REFS0) | (0<<ADLAR) | (1<<MUX3) | (1<<MUX2) | (1<<MUX1) | (0<<MUX0);    //Posem els bits REFS a [1 1] per així tenir la referència interna de 1.1V, amb la qual obtindrem més resolució (1.1/1024).
                                                                                                    //Fixem l'ADLAR=0, per tenir ADC[7..0] al ADCL i els ADC[9..8] al ADCH.
                                                                                                    //Fixem els bits de MUX a [1110], per comprovar que la conversió s'està fent de forma correcta.
                                                                                                    //Un cop connectat el sensor, cladria fixar els bits de MUX a [1000] ja que és l'entrada pel sensor de temperatura.
   ADCSRA |= 1 << ADEN;                             //Posem l'ADC en marxa
   ADCSRA |= 1 << ADATE;                            //Habilitem l'AUTO TRIGGERING. L'ADC començarà la conversió quan hi hagi un flanc de pujada a un altre senyal de trigger que es fixarà al ADTS.
                                                    //L'interrupció ADIF es posa a 1 quan ha acabat conversió.
   ADCSRA |= 1 << ADIE;                             //Si es defineix el bit ADIE a 1 significa que quan l’ADC fa una mesura, es produeix una interrupció, la interrupció despertarà el xip del mode SLEEP.
   ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));    //Fixem el Prescaler a 128 de manera que tenim un clock de 125Khz per fer les mesures.
                                                    //El rellotge ADC ha d’estar entre 50kHz i 200kHz, ja que el rellotge Uno és de 16MHz volem dividir-lo per 128 per obtenir 125kHz.
                                                    // No hem d’utilitzar registres per configurar el mode SLEEP ja que utilitzem la biblioteca avr / sleep.h
  sleep_enable();                                   //Habilitem al funció d'SLEEP.
  set_sleep_mode(SLEEP_MODE_ADC);                   //Fixem el mode d'SLEEP. Estem utilitzant el "ADC noise reduction sleep mode".
                                                    //Tingueu en compte que en aquest mode SLEEP el xip inicia automàticament una mesura ADC un cop el xip entra en mode SLEEP.
}


void loop()
{
   if (Serial.available())                                            //Quan el port serial estigui disponible, quan hi arribi alguna dada
   {
      char comanda[20];                                               //Comanda és el missatge que ens envia el mestre
      size_t count = Serial.readBytesUntil('\n', comanda, 20);        //Comptem els caracters que hi ha a la comanda fins arribar al caracter '\n', serveix per implementar el DEBUG
      //DEBUG(comanda, count);

  switch(comanda[1]){                                                 //En funció de quin caracter tenim a la posició 1 del buffer, executem una instrucció o una altra
        case 'M':
          operaciom(comanda, count);                                  //A la funció de Operació MARXA, li enviem el buffer sencer i la seva longitut.
        break;
        case 'S':
        break;
        case 'E':
        break;
        case 'C':
        break;
      }
   }
}

void operaciom(char comandam[20], int caracters){     //Funció un cop s'ens ha demanat la instrucció de MARXA/PARA.
    char respostaerror1m[4]={'A','M','1','Z'};        //Definim el array que s'envia al mestre en cas d'error 1.
    char respostaerror2m[4]={'A','M','2','Z'};        //Definim el array que s'envia al mestre en cas d'error 2.
    int error = 0;
    int mostreig = 0;
    int t1 = comandam[3] - '0';                       //Convertim el byte alt del nombre de segons de mostreig a integer.
    int t2 = comandam[4] - '0';                       //Convertim el byte baix del nombre de segons de mostreig a integer.
    mostreig = t1*10 + t2;                            //Formem un sol nombre que és el temps de mostreig.
    
    for (int index = 2; index < caracters; index++){  //Avaluem cada caracter del buffer, en cas d'haver-hi una altra 'A' que el seu codi ASCII és 65,
      if( comandam[index] == 'A' ){                   // que no estigui en la posició 1, incrementem la variable error que farà enviar una resposta d'error.
        error = error + 1;
      }
    }

    if(comandam[5] != 'Z' || error > 0){              //Si no hi ha una 'Z' a la posició 5, o hi ha més d'una 'A', enviem error 1.
      DEBUG(respostaerror1m,4);
    }else if(mostreig > 20 || mostreig < 1){          //Comprobem que el temps de mostratge rebut estigui entre 1 i 20,
      DEBUG(respostaerror2m,4);                       //sinò, enviem el missatge d'error 2.
      }else{                                          
        char respostam[4]={'A','M','0','Z'};          //En cas de ser la comanda correcte, treiem missatge amb codi de retorn '0 = OK'.
        DEBUG(respostam,4);
      }
}
